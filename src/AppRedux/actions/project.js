import {
  CREATE_PROJECT_BEGIN,
  CREATE_PROJECT_SUCCESS,
  CREATE_PROJECT_FAILURE,
  RESET_CREATE_PROJECT,
  ADD_VULNERABILITY_BEGIN,
  ADD_VULNERABILITY_SUCCESS,
  ADD_VULNERABILITY_FAILURE,
  RESET_ADD_VULNERABILITY,
  GET_PROJECTS_BEGIN,
  GET_PROJECTS_SUCCESS,
  GET_PROJECTS_FAILURE,
  RESET_GET_PROJECTS,
  GET_VULNERABILITIES_BEGIN,
  GET_VULNERABILITIES_SUCCESS,
  GET_VULNERABILITIES_FAILURE,
  RESET_GET_VULNERABILITIES,
  GET_SINGLE_PROJECT_BEGIN,
  GET_SINGLE_PROJECT_FAILURE,
  GET_SINGLE_PROJECT_SUCCESS,
  RESET_GET_SINGLE_PROJECT,
} from "../constants/project";

import http from "../../axios/httpUser";

export function createProject(data) {
  return (dispatch) => {
    dispatch({
      type: CREATE_PROJECT_BEGIN,
    });

    const promise = new Promise((resolve, reject) => {
      let doRequest = http.post(`/project`, data);

      doRequest.then(
        (res) => {
          dispatch({
            type: CREATE_PROJECT_SUCCESS,
            data: res.data,
          });
          dispatch({
            type: RESET_CREATE_PROJECT,
          });

          resolve(res);
        },
        (err) => {
          dispatch({
            type: CREATE_PROJECT_FAILURE,
            data: err.response.data,
          });
          dispatch({
            type: RESET_CREATE_PROJECT,
          });

          reject(err);
        }
      );
    });

    return promise;
  };
}

export function addVulnerability(projectId, data) {
  return (dispatch) => {
    dispatch({
      type: ADD_VULNERABILITY_BEGIN,
    });

    const promise = new Promise((resolve, reject) => {
      let doRequest = http.post(`/project/${projectId}/vulnerability`, data);

      doRequest.then(
        (res) => {
          dispatch({
            type: ADD_VULNERABILITY_SUCCESS,
            data: res.data,
          });
          dispatch({
            type: RESET_ADD_VULNERABILITY,
          });

          resolve(res);
        },
        (err) => {
          dispatch({
            type: ADD_VULNERABILITY_FAILURE,
            data: err.response.data,
          });
          dispatch({
            type: RESET_ADD_VULNERABILITY,
          });

          reject(err);
        }
      );
    });

    return promise;
  };
}

export function getAllProjects() {
  return (dispatch) => {
    dispatch({
      type: GET_PROJECTS_BEGIN,
    });

    const promise = new Promise((resolve, reject) => {
      let doRequest = http.get(`/project?search=&limit=10&page=1`);

      doRequest.then(
        (res) => {
          dispatch({
            type: GET_PROJECTS_SUCCESS,
            data: res.data,
          });
          dispatch({
            type: RESET_GET_PROJECTS,
          });

          resolve(res);
        },
        (err) => {
          dispatch({
            type: GET_PROJECTS_FAILURE,
            data: err.response.data,
          });
          dispatch({
            type: RESET_GET_PROJECTS,
          });

          reject(err);
        }
      );
    });

    return promise;
  };
}

export function getVulnerabilities() {
  return (dispatch) => {
    dispatch({
      type: GET_VULNERABILITIES_BEGIN,
    });

    const promise = new Promise((resolve, reject) => {
      let doRequest = http.get(`/vulnerability?search=&limit=1000&page=1`);

      doRequest.then(
        (res) => {
          dispatch({
            type: GET_VULNERABILITIES_SUCCESS,
            data: res.data,
          });
          dispatch({
            type: RESET_GET_VULNERABILITIES,
          });

          resolve(res);
        },
        (err) => {
          dispatch({
            type: GET_VULNERABILITIES_FAILURE,
            data: err.response.data,
          });
          dispatch({
            type: RESET_GET_VULNERABILITIES,
          });

          reject(err);
        }
      );
    });

    return promise;
  };
}

export function getSingleProject(projectId) {
  return (dispatch) => {
    dispatch({
      type: GET_SINGLE_PROJECT_BEGIN,
    });

    const promise = new Promise((resolve, reject) => {
      let doRequest = http.get(`/project/${projectId}`);

      doRequest.then(
        (res) => {
          dispatch({
            type: GET_SINGLE_PROJECT_SUCCESS,
            data: res.data,
          });
          dispatch({
            type: RESET_GET_SINGLE_PROJECT,
          });

          resolve(res);
        },
        (err) => {
          dispatch({
            type: GET_SINGLE_PROJECT_FAILURE,
            data: err.response.data,
          });
          dispatch({
            type: RESET_GET_SINGLE_PROJECT,
          });

          reject(err);
        }
      );
    });

    return promise;
  };
}
